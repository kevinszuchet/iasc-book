<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>IASC Book</title>

    <!-- Bootstrap CSS CDN -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
    <!-- Our Custom CSS -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700">
    <link rel="stylesheet" href="/iasc-book/css/style.css">
    <link rel="stylesheet" href="/iasc-book/css/blockquote.css">
    <link rel="stylesheet" href="/iasc-book/css/syntax.css">

    <!-- Font Awesome JS -->
    <script defer src="https://use.fontawesome.com/releases/v5.0.13/js/solid.js" integrity="sha384-tzzSw1/Vo+0N5UhStP3bvwWPq+uvzCMfrN1fEFe+xBmv1C/AtVX5K0uZtmcHitFZ" crossorigin="anonymous"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.0.13/js/fontawesome.js" integrity="sha384-6OIrr52G08NpOFSZdxxz1xdNSndlD4vdcf/q2myIUVO0VsqaGHJsB0RaBE01VTOY" crossorigin="anonymous"></script>

</head>

<body>

<div class="wrapper">

    <!-- Sidebar Holder -->
<nav class="sidebar">
    <div class="sidebar-header">
        <a href="/iasc-book">
            <h3 class="title">IASC Notes</h3>
        </a>
    </div>

    <ul class="list-unstyled components">
        <p>Temas</p>
        <li>
            <a href="/iasc-book/introduccion">Intro</a>
        </li>
        <li>
            <a href="/iasc-book/cps">CPS</a>
        </li>
        <li>
            <a href="/iasc-book/coroutines">Corrutinas</a>
        </li>
        <li>
            <a href="#actoresSubmenu" data-toggle="collapse" aria-expanded="false" class="dropdown-toggle">Actores</a>
            <ul class="collapse list-unstyled" id="actoresSubmenu">
                <li>
                    <a href="/iasc-book/actores_intro">Introduccion Actores</a>
                </li>
                <li>
                    <a href="/iasc-book/otp">Elixir OTP</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#stmSubmenu" data-toggle="collapse" aria-expanded="false" class="dropdown-toggle">Memoria
                Transaccional</a>
            <ul class="collapse list-unstyled" id="stmSubmenu">
                <li>
                    <a href="/iasc-book/efecto_lado_haskell">Efectos de lado en Haskell</a>
                </li>
                <li>
                    <a href="/iasc-book/stm">STM</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#distriSubmenu" data-toggle="collapse" aria-expanded="false"
               class="dropdown-toggle">Distribucion</a>
            <ul class="collapse list-unstyled" id="distriSubmenu">
                <li>
                    <a href="/iasc-book/distribucion">Introduccion a distribucion</a>
                </li>
                <li>
                    <a href="/iasc-book/cap">Notas sobre CAP</a>
                </li>
            </ul>
        </li>
    </ul>

    <div class="sidebar-header">
        <form action="/iasc-book/search" method="get">
            <input type="text" class="search-leftbar" id="search_box" name="query">
            <input type="submit" value="Buscar">
        </form>
    </div>
</nav>

    <div class="container header">
        <nav class="navbar navbar-expand-lg navbar-light">
    <button type="button" id="sidebarCollapse" class="btn btn-info">
        <i class="fa fa-align-justify"></i> <span>toggle sidebar</span>
    </button>
    <!--<a class="navbar-brand" href="#">Navbar</a> -->
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ml-auto">
            <li class="nav-item active">
                <a class="nav-link" href="/iasc-book">Home <span class="sr-only">(current)</span></a>
            </li>
            <li class="nav-item">
                <a class="nav-link navbar-button" href="http://arquitecturas-concurrentes.github.io/">IASC</a>
            </li>
        </ul>
    </div>
</nav>


        <div class="titulo-heading">
    <div class="container-background">
        <div class="titulo">
            <h3 class="Title">
                Capitulo 7 - Actores
            </h3>
            <br>
            <h4>
                Actores y Elixir
            </h4>
        </div>
    </div>
</div>

        <div class="container">

            <div class="inner-content col-sm-8 col-md-10">
                <h2 id="introduccion">Introduccion</h2>

<p>El modelo de Actores, como vimos, tiene muchas similitudes al paradigma de objetos aunque con algunas diferencias. El modelo de actores en si se define como uno que puede lidiar con computaciones concurrentes, por lo que hay algunas reglas en cómo deben ser modelados estos componentes, su comportamiento e interacción. 
El modelo de actores tiene su unidad de computación más primitiva que es un actor, y que es una computación que recibe un mensaje y hace un procesamiento en base a eso, tambien ademas de recibir mensajes, puede enviar mensajes, tiene una identidad, que es mediante un id único en el sistema. Si empezamos a ver que un actor posee identidad, y envío/recepción de mensajes, uno pensaría que es bastante similar a la de un objeto, o no?. Bueno también un actor, cuando recibe un mensaje, hace algo dependiendo del mensaje que recibe ( similar a cuando llamamos a un método determinado a un objeto). Existen diferencias entre actores y objetos, y la más notoria es que en un modelo de objetos, varios objetos se ejecutan en una unidad de procesamiento (proceso o thread) y comparten recursos como memoria, esto no es lo mismo en el paradigma de actores en el que los actores son en realidad un contexto de ejecución y están completamente aislados uno de otros y nunca van a compartir memorias u otros recursos. También se debe aclarar que un actor puede mantener un estado privado y que este no puede ser cambiado directamente por otro actor (encapsulamiento). En el modelo de actores, nuestro sistema tiene que estar diagramado en actores y todo es un actor, y tienen que tener direcciones siempre, y esta dirección es lo que hablábamos antes que era el identificador en el ecosistema.</p>

<p>Los Actores además tienen un mailbox (buzón), en donde van a poder recibir los mensajes de otros actores, y por qué es esto? Bueno porque el envío de mensajes entre actores es asincrónico, por lo cual nunca se sabe exactamente cuando un actor recibe un mensaje, y el modelo elige este modelo de envío de mensajes, ya que al ser una unidad de ejecucion tambien, si se hacen llamadas sincrónicas, el proceso se quedara esperando a una respuesta que puede tal vez nunca llegar o demorar mucho más tiempo, quedando este proceso bloqueado mientras tanto y no dejando de que se pueda ejecutar otro actor que tal vez puede procesar algo. Al poder un actor recibir más de un mensaje en poco tiempo, y al procesar estos de a uno, si se recibe otro mensaje, el actor no lo puede recibir y procesar inmediatamente, por lo que estos mensajes que por el momento el actor no puede procesar quedan encolados en el buzón.
También estos escenarios suceden al tener múltiples actores que pueden ejecutarse al mismo tiempo, aunque un actor puede procesar un mensaje al mismo tiempo por lo que de nuevo, si un actor recibe al mismo tiempo 3 mensajes, va a ejecutar uno solo a la vez y por lo tanto hay que mantener un estado de que después hay dos mensajes más por ser procesados, esta es la razón de que los actores tengan un buzón. Si queremos que se ejecuten concurrentemente 3 mensajes, deberemos tener 3 actores y que se le envie un mensaje a cada uno.</p>

<p><img src="/iasc-book/images/actors.png" height="350" class="center" /></p>

<h2 id="que-pueden-hacer-los-actores">Que pueden hacer los actores</h2>

<ul>
  <li>Enviar y procesar mensajes de otros actores</li>
  <li>Crear mas actores</li>
  <li>ejecutar otro código después de procesar un mensaje.</li>
</ul>

<p>Mencionamos que los actores son también una abstracción que tiene un contexto de ejecución propio, quien se encarga entonces de ejecutar a los actores. En la VM de Erlang/Elixir, existe algo llamado Scheduler, que se encarga de la coordinación de los actores y de la ejecución sobre un procesador del actor. <a href="http://erlang.org/pipermail/erlang-questions/2001-April/003132.html">Mas sobre el scheduler de BEAM</a></p>

<p>Que pasa cuando un actor no tiene ningun mensaje mas para procesar? El mismo muere. El ciclo de vida de un actor es relativamente corto y está pensado para que realice una acción en particular, reciba, envíe mensajes y cree otros actores, pero cuando deja de tener acciones futuras a realizar el mismo muere. Cómo podemos evitar que esto suceda? Bueno si queremos que un actor pueda quedar vivo, esperando a que reciba un mensaje eventualmente, podemos tan solo hacer eso llamándose a sí mismo y haciendo eso. Podemos ver un ejemplo <a href="https://github.com/arquitecturas-concurrentes/iasc-actors-intro-elixir/blob/master/elixir/intro_actors/lib/intro_actors.ex">aquí</a></p>

<p>Otro tema importante es que un actor no tiene métodos como los objetos, y el comportamiento de esta última está provista por las clases siempre. En Elixir/Erlang, existe algo más o menos similar que son los módulos, que podemos definir funciones que podemos pasarlas al actor para que las ejecute, es importante la siguiente línea del ejemplo anterior</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">spawn</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="k">loop</span> <span class="k">end</span><span class="p">)</span>
</code></pre></div></div>

<p>Spawn es la primitiva para crear un actor, y se le puede pasar una función que sea un loop que se llame a sí mismo y de acuerdo al mensaje que reciba realizará una acción. Esta es la manera más simple de que un actor quede vivo después de procesar los mensajes que tiene en el mailbox.</p>

<p>Hay otra librería que nos ayuda mucho a no tener que preocuparnos por esto que es OTP, que nos va a ayudar a modelar, mediante módulos que son más bien recurrentes, diferente tipos de actores que harán distintas acciones puntuales que nos van a ayudar bastante a que nos centremos más en el dominio de nuestra aplicación.</p>

<p>Que pasa si un actor falla por alguna razón? Bueno el mismo muere y hay que volver a crearlo y si recibió un mensaje en particular hay que enviarselo de nuevo, hay maneras de que podamos evitar esto mediante catcheo de excepciones, aunque puede ser a veces que pueda morir por otras razones, con lo cual a veces es mejor dejar de morir un actor solo… Entonces que hago para poder volver a levantar un actor que se murió sin que tenga que hacerlo uno a mano? Hay un módulo de OTP que veremos en la próxima sección que nos ayuda con este tema y son los supervisores.</p>

<p>Más info sobre errores en el ecosistema de Erlang/Elixir <a href="https://learnyousomeerlang.com/errors-and-exceptions#not-so-fast">aqui</a></p>

<p>Adicional:</p>

<p>Leer principalmente la primera parte que describe brevemente el paradigma de actores junto con actores en Erlang y el scheduling en Erlang.</p>

<p><a href="https://rocketeer.be/articles/concurrency-in-erlang-scala/">https://rocketeer.be/articles/concurrency-in-erlang-scala/</a></p>

            </div>
        </div>
    </div>
</div>


<div class="footer">
    <div class="columns small-12 medium-12 large-12">
        © 2020 - IASC
    </div>
</div>
<!-- jQuery CDN - Slim version (=without AJAX) -->
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"></script>
<!-- Popper.JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"
        integrity="sha384-cs/chFZiN24E4KMATLdqdvsezGxaGsi4hLGOzlXwp5UZB1LY//20VyM2taTB4QvJ"
        crossorigin="anonymous"></script>
<!-- Bootstrap JS -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"
        integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm"
        crossorigin="anonymous"></script>
<!-- Lunr JS Search -->
<!-- <script src="https://unpkg.com/lunr/lunr.js"></script> -->
<script src="https://unpkg.com/lunr@1.0/lunr.js"></script>
<script src="/iasc-book//js/search.js"></script>


<!--This part will enable the circle button to show/hide the right bar-->
<script type="text/javascript">
    $(document).ready(function () {
        $('#sidebarCollapse').on('click', function () {
            $('.sidebar').toggleClass('sidebar-inactive');
            $(this).toggleClass('active');
        });
    });
</script>


</body>

</html>
